---
layout: post
title:  "动态规划-编辑距离"
date:   2021-04-12 11:01:00 +0000
categories: alogrithm
---

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1：**

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

原题链接：https://leetcode-cn.com/problems/edit-distance

仍然学习 https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zi-xu-lie-lei-xing-wen-ti/bian-ji-ju-li

的思路，分别从递归和动态规划角度来实现：

解题的入手点在于如何将问题拆解，找到初始点，在参考上面的答案前独立思考了一段时间，但却不知道从哪里开始。

同时也对比了些不同人对这个问题的分析和写法，但普遍都默认或者假设做题的人都已经理解了一些东西，因此总感觉解析的过程前后脱节，对一些地方没有说清楚原因。

如何去实现s1到s2的转换，引用上面博主的话：**主要是通过将一对指针从两个字串最后以某种规则向前移动来实现，在移动的过程中将问题划分出不同的场景，进入递归**。这也是使用动态规划解决字串问题的通用方法。

| s1   | h    | o    | r    | s    | e    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| s2   | r    | o    | s    |      |      |

s1经过了替换h->删除r->删除e到达了s2，这是最理想的路径，而如果不考虑路径长度也可以通过替换h->替换r->删除s->删除e来实现，但显然路径就更长了，而造成长短的差别在于对某一个字符进行处理时选择的处理方式不同，也就说对其中的某一个环节，选择替换、删除、添加都可以达到最终的目的，因此这个对某一个环节的处理方式就可以作为递归的入口，并取其中最短的值作为返回值。

递归入口找到后，再看其中特殊情况1，就是递归的时候总会遇到两个字符相同的情况，这显然不需要额外的处理，而是可以直接通过跳过来减少步骤的。

特殊情况2，就是递归最后一定出现了某一个字串已经处理结束，或者两者都处理结束，这时只需要去增加或者减少字符就可以使两个字串更趋近相同，而不需要用不同的操作对比。这也是递归或者动态规划的base case。

因此有了这种基本的写法：

```python
def minDistance(s1, s2) -> int:

    def dp(i, j):
        # base case
        if i == -1: return j + 1
        if j == -1: return i + 1

        if s1[i] == s2[j]:
            return dp(i - 1, j - 1)  # 啥都不做
        else:
            return min(
                dp(i, j - 1) + 1,    # 直接处理了j的前一个j-1，因此一定是在i中插入了一个和j一样的
                dp(i - 1, j) + 1,    # 直接处理了i的前一个i-1，因此当前这个i一定是被删除了
                dp(i - 1, j - 1) + 1 # 直接把i和j都向前走，一定是i被替换成和j一样的了
            )

    # i，j 初始化指向最后一个索引
    return dp(len(s1) - 1, len(s2) - 1)
```

而这种处理方式仍然需要处理重叠问题：

dp(i,j) => dp(i - 1, j - 1)

dp(i,j) => dp(i, j-1) => dp(i-1, j) => dp(i-1,j-1)

因此增加备忘录的版本为：

```python
def minDistance(s1, s2) -> int:

    memo = dict() # 备忘录
    def dp(i, j):
        if (i, j) in memo: 
            return memo[(i, j)]

        if s1[i] == s2[j]:
            memo[(i, j)] = dp(i-1, j-1)
        else:
            memo[(i, j)] = min(
            	dp(i, j - 1) + 1,
            	dp(i - 1, j) + 1,
            	dp(i - 1, j - 1) + 1)
        return memo[(i, j)]

    return dp(len(s1) - 1, len(s2) - 1)
```

使用动态规划的方法解决这个问题依然是使用自底向上的方式，但使用动态规划的方式时很难直接想到dp的定义，通过上面的递归实现后确实可以很好的分析出dp的定义来（二维数组），这也是看了几篇文章都感觉不是很容理解的原因吧。

直接将原作者的c++代码搬来：

```c++
int minDistance(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    int[][] dp = new int[m + 1][n + 1];// 个人感觉这个不是很容易理解，但通过上面的自顶向下的递归方式就容易接受多了，差不多可以理解成长度为i字串s1转换成长度为j的s2需要的最少步骤吧
    // base case 
    // 这样的初始化类似都设置成了最大值
    for (int i = 1; i <= m; i++)
        dp[i][0] = i;
    for (int j = 1; j <= n; j++)
        dp[0][j] = j;
    // 自底向上求解
    for (int i = 1; i <= m; i++) // 分别循环i，j来求解不同s1转换成s2的步骤长度
        for (int j = 1; j <= n; j++)
            if (s1.charAt(i-1) == s2.charAt(j-1))
                dp[i][j] = dp[i - 1][j - 1];// 同理遇到相同的字符不增加转换步骤
            else               
                dp[i][j] = min(
                    dp[i - 1][j] + 1,// 仍然用s1的上一个作为转换源，那s1[i]一定是被删除了，如s1=“12345”，s2=“1245”
                    dp[i][j - 1] + 1,// 仍然用s2的上一个作为转换目标，那么s1[i]处一定是插入了一个s2[j],如s1=“1234”，s2=“12345”
                    dp[i-1][j-1] + 1 // 比s1长度-1和s2长度-1转换步骤多了1，因此时替换操作，如s1=“12345”，s2=“12045”
                );
    // 储存着整个 s1 和 s2 的最小编辑距离
    return dp[m][n];
}

int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}
```

写道这里原本就可以结束了，但突然想

```
if s1[i] == s2[j]:
            return dp(i - 1, j - 1)  # 啥都不做
```

这个代码块不可以和后面的几个选择合并吗，然后试了下，发现计算错误了，稍稍想了下，其实合并是可以的，但只能这样写：

```
def minDistance(s1, s2):
    def dp(i, j):
        # base case
        if i == -1: return j + 1
        if j == -1: return i + 1

        if s1[i] == s2[j]:
            return min(
                dp(i - 1, j - 1),
                dp(i, j - 1) + 1,
                dp(i - 1, j) + 1,
                dp(i - 1, j - 1) + 1)
        else:
            return min(
                dp(i, j - 1) + 1,
                dp(i - 1, j) + 1,
                dp(i - 1, j - 1) + 1
            )
    return dp(len(s1) - 1, len(s2) - 1)
```

原因是，只有在两个字符相等的情况下才有dp(i - 1, j - 1)，才可以直接跳过，而其他情况均不能直接跳过，所以没法把这个分支直接放在下面的min中，但像上面这样写反而麻烦了，因为直接跳过一定是最短的，而不需要和另外三种情况去对比。

再回头想想，自己好像有点蠢呢;(