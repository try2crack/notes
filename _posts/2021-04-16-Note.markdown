---
layout: post
title:  "动态规划-最长递增序列"
date:   2021-04-16 07:017:00 +0000
categories: alogrithm
---

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。

题目为标准的动态规划类型，规划中最重要的是为dp[i]选择合适的意义，使问题简化，思路清晰。

此时看到题目，首先想到dp[i]的意义可能是前i个序列的最长的子序列，假设如此，那么怎样通过dp[i-1]转化到dp[i]呢，假设前i-1个序列中最长的子序列为l，那么前i个序列的最长子序列就为l+1了吗？无法得到这样的规律，因为前i-1个序列的最长子序列中最大的变量的位置和值是无法确认的，值可能比array[i]要大，也可能比array[i]小，可是如果先求得前i-1最长递增序列中的最大值m，然后来和array[i]来判断了，如果array[i] > m,则dp[i] = m+1,否则，dp[i] = m是不是就可以了呢？

答案也是不可以，比如这个序列：a = [4,5,6,1,2,3,4,5]
从这个序列可以看出，用上面描述的方法根本就行不通，在计算dp[6]时，也就是a[6]并没有大于dp[5]中的最大值（最大值为6），依照这个逻辑，dp[3]到dp[6]在整个推导过程中根本没法选取新的起始元素（被前面三个元素行形成的最长序列阻碍住了），也就没有办法生成比原最长序列更长但元素数值更小的递增序列了。所以dp[i]所代表的含义，必须可以让递增序列的起始元素动态变化,而不是在所有的序列里与最大值比较。

现在需要给dp[i]新的含义，可以保证从任何位置开始的序列都可能被计算到，dp[i]表示以a[i]为最长递增序列最后元素的递增序列的长度。这样定义dp[i]的好处就是这个最长序列从哪里开始都可以，但仍然存在合适的递推逻辑，就是只要在dp[0]到dp[i-1]中存在某一个dp[x],他的值比a[i]小，那么a[i]就完全可以列入这个最长序列中，使dp[i] = dp[x] + 1;取dp[0]到dp[i-1]中比a[i]小，但是最贴近a[i]的那个，就可以让dp[i]最大了，当i=len(a)长度时，就是题目所求：

因此解题代码：
```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 1); // dp初始化为1
        int ret = 1;

        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = (dp[i] > (dp[j] + 1)) ? dp[i] : (dp[j] + 1);
                }
            }
        }
        
        for (int i = 0; i < dp.size(); i++) {
            ret = ret > dp[i] ? ret : dp[i]; 
        }

        return ret;
    }
};
```