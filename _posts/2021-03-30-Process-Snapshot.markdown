---
layout: post
title:  "AFL进程快照尝试"
date:   2021-03-30 23:30:00
categories: Fuzz技术
---

## 背景描述
AFL的变异机制在fuzz应用中有很好的表现，尤其是对格式解析器一类的fuzz。通过persist-mode、qemu-mode的多种模式可以以插桩的形式适配到较多的场景，但还是无法满足到一些对状态（或者说上下文）有较高要求的情况。
如网络协议模块，一个完整的协议通常包含了多次交互，而协议数据流的上下文也可能存在于多个线程环境中，这种协议通常包含了多个状态，因此在对协议进行fuzz时，需要对多个不同的状态分别进行fuzz，但AFL本身的fork机制就导致了上下文的丢失，因为fork后的进程仅包含了调用fork前对应的线程实体，父进程原本的其他线程就被丢失了。

## 解决问题方法
-   修改AFL实现，寻找一个合适的fork点，可以在协议所在进程只有一个线程时执行fork，即在进程未新创建线程前。
    这样的时机理论上是可以找到的，在有全部代码的情况下可以直接阅读代码，在没有代码的情况下也可以通过逆向等手段实现，但这也有一个问题，就是这个点找到了，但效率却可能下降了，比如：这个点的后面需要创建多个线程，但多个线程的创建之间执行了一些较为耗时的操作，因此，从这个点fork后要等一定的时间才可以真正的执行fuzz，导致整体运行时的fuzz较慢。
-   同样修改AFL实现，但使用persist模式，而不是频繁的执行fork，这样可以降低对效率的影响，其实这种策略也是对第一种方法的折中，但在persist模式下可能会导致数据的污染，因为相比于fork模式，它无法保证某次的数据流产生的结果不会对下一次影响，毕竟是一直针对同一个进程fuzz，进程的内存是随着不同的输入变化的。

针对以上两个解决方案，都有各自的缺点，比较难解决的问题是：如何在fuzz时，第二次的fuzz执行前的状态可以和第一次的fuzz执行前的状态一样干净，没有受到污染，如果这个可以保证那原本的persist模式是比较合适的，因为在这种情况下fork后再按照合适的LOOP去执行fuzz对效率影响也可以忽略了。

因此就有了进程快照的想法，进程快照和虚拟机快照类似，就是可以在特定的时机创建快照，快照中包含进程当前的内存，所有的线程用户态和内核态状态，也可能包含文件句柄等信息，之所以包含众多信息，是为了在恢复快照时可以保证进程中所有进程可以向快照创建时正常工作，目前来分析至少包含以下几部分内容：

- 线程用户态内存
- 线程内核态内存
- 线程运行时内核上下文

而这三部分中还需要做进一步的区分，比如根据实现方式，需要区分调用者线程，和其他线程，因为针对调用者线程在执行快照恢复时的情况也有些特殊，大致有两种思路，一个是恢复到快照时的CPU状态（主要是用户态的各种寄存器），一个使当前调用线程直接按顺序执行完内核调用后返回到用户态的原有流程。

## 未完

